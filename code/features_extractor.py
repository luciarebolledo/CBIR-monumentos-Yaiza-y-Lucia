# -*- coding: utf-8 -*-
"""Features_extractor.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z5NtJVKJpqW5WckCTJrrlCVBHnBwduaT
"""

import os
import numpy as np
import cv2
from skimage.feature import local_binary_pattern
import faiss
from PIL import Image
from tensorflow.keras.applications import VGG16
from tensorflow.keras.applications.vgg16 import preprocess_input
from tensorflow.keras.preprocessing import image

# Ruta donde se guardarán los índices FAISS
DB_PATH = os.path.join(os.getcwd(), 'database')

# Crear la carpeta `database` si no existe
if not os.path.exists(DB_PATH):
    os.makedirs(DB_PATH)

# Ruta a las imágenes de entrenamiento
TRAIN_PATH = os.path.join(os.getcwd(), 'train')

# Preprocesamiento

# Normalización de imágenes
def normalize_image(image):
    imagen = np.array(image) / 255.0
    return (imagen * 255).astype(np.uint8)

# Redimensionar imágenes a un tamaño fijo
def resize_image(image, size=(256, 256)):
    return image.resize(size)

# Función para preprocesar imágenes de una carpeta
def preprocess_images(folder_path):
    processed_images = []
    image_files = [f for f in os.listdir(folder_path) if f.endswith(('jpg', 'png', 'jpeg'))]

    for image_file in image_files:
        try:
            image_path = os.path.join(folder_path, image_file)
            image = Image.open(image_path)
            image_resized = resize_image(image)
            image_normalized = normalize_image(image_resized)
            processed_images.append(image_normalized)
        except Exception as e:
            print(f"Error procesando la imagen {image_file}: {e}")
    return processed_images

# Funciones de extracción de características

# Extractor 1: Histograma de color
def calcular_histograma_color(image, bins=(8, 8, 8)):
    hsv_image = cv2.cvtColor(image, cv2.COLOR_RGB2HSV)
    hist = cv2.calcHist([hsv_image], [0, 1, 2], None, bins, [0, 180, 0, 256, 0, 256])
    return cv2.normalize(hist, hist).flatten()

# Extractor 2: Descriptores de Textura (Patrones Binarios Locales - LBP)
def calcular_texturas(image, num_points=24, radius=8):
    gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    lbp = local_binary_pattern(gray_image, num_points, radius, method="uniform")
    hist, _ = np.histogram(lbp.ravel(), bins=np.arange(0, num_points + 3), range=(0, num_points + 2))
    return hist.astype("float") / hist.sum()

# Extractor 3: Descriptores de Forma (Momentos de Hu)
def calcular_momentos_hu(image):
    gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    edges = cv2.Canny(gray_image, 100, 200)
    moments = cv2.moments(edges)
    hu_moments = cv2.HuMoments(moments).flatten()
    return hu_moments, edges

# Extractor 4: CNN preentrenadas
# Cargar el modelo VGG16 preentrenado sin la capa final de clasificación
model = VGG16(weights='imagenet', include_top=False)

def calcular_cnn(image):
    # Asegurarse de que la imagen esté en formato PIL (si no lo está, convertirla)
    if not isinstance(image, Image.Image):
        image = Image.fromarray(image)  # Convertir array a imagen PIL si es necesario
    image = image.resize((224, 224))  # Redimensionar la imagen al tamaño que espera la red
    img_array = np.array(image)  # Convertir imagen a un array de NumPy
    img_array = np.expand_dims(img_array, axis=0)  # Añadir una dimensión extra para el lote
    img_array = preprocess_input(img_array)  # Preprocesamiento que espera VGG16
    features = model.predict(img_array)  # Extraer características
    return features.flatten()


# Extractor 5: Descriptores SIFT
def calcular_sift(image):
    # Crear el detector SIFT
    sift = cv2.SIFT_create()
    # Convertir la imagen a escala de grises
    gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
    # Detectar los puntos clave y calcular los descriptores SIFT
    keypoints, descriptors = sift.detectAndCompute(gray_image, None)
    return keypoints, descriptors

def promedio_descriptores_sift(sift_descriptors):
    """Calcula el promedio de los descriptores SIFT de una imagen.
       Si no hay descriptores, devuelve un vector de ceros.
    """
    if sift_descriptors is not None and len(sift_descriptors) > 0:
        return np.mean(sift_descriptors, axis=0)
    else:
        return np.zeros(128)

# GUARDAMOS NUESTRAS CARACTERÍSTICAS EN UN DICCIONARIO

# Inicializar el diccionario maestro para almacenar todas las características
caracteristicas_imagenes_train = {
    'color': {},
    'textura': {},
    'forma': {},
    'CNN': {},
    'SIFT': {}
}

# Procesar imágenes desde el directorio `train/`
processed_train_images = preprocess_images(TRAIN_PATH)

# Verificar si se procesaron imágenes
if len(processed_train_images) == 0:
    raise ValueError("No se encontraron imágenes para procesar en la carpeta de entrenamiento.")

# Lista de nombres de las imágenes para usar como claves
image_names = [f"imagen_{i}" for i in range(len(processed_train_images))]

# Iterar sobre las imágenes y extraer características
for i, image in enumerate(processed_train_images):
    image_name = image_names[i]  # Obtener el nombre de la imagen

    try:
        # Calcular características para cada imagen
        hist_color = calcular_histograma_color(image)
        hist_texturas = calcular_texturas(image)
        hu_moments, _ = calcular_momentos_hu(image)
        cnn = calcular_cnn(image)
        _, sift_descriptors = calcular_sift(image)
        sift_vector = promedio_descriptores_sift(sift_descriptors)

        # Guardar las características en sus respectivos sub-diccionarios
        caracteristicas_imagenes_train['color'][image_name] = hist_color
        caracteristicas_imagenes_train['textura'][image_name] = hist_texturas
        caracteristicas_imagenes_train['forma'][image_name] = hu_moments
        caracteristicas_imagenes_train['CNN'][image_name] = cnn
        caracteristicas_imagenes_train['SIFT'][image_name] = sift_vector

    except Exception as e:
        print(f"Error calculando características para la imagen {image_name}: {e}")

# Crear índices FAISS para color, textura y forma
index_color = faiss.IndexFlatL2(len(hist_color))
index_textura = faiss.IndexFlatL2(len(hist_texturas))
index_forma = faiss.IndexFlatL2(len(hu_moments))
index_cnn = faiss.IndexFlatL2(len(cnn))
index_sift = faiss.IndexFlatL2(len(sift_vector))

# Rellenar los índices con las características del diccionario maestro
for image_name in caracteristicas_imagenes_train['color']:
    try:
        # Histograma de color
        hist_color = np.array(caracteristicas_imagenes_train['color'][image_name]).reshape(1, -1).astype('float32')
        index_color.add(hist_color)

        # Descriptores de textura
        hist_texturas = np.array(caracteristicas_imagenes_train['textura'][image_name]).reshape(1, -1).astype('float32')
        index_textura.add(hist_texturas)

        # Momentos de Hu (forma)
        hu_moments = np.array(caracteristicas_imagenes_train['forma'][image_name]).reshape(1, -1).astype('float32')
        index_forma.add(hu_moments)

        # CNN
        cnn = np.array(caracteristicas_imagenes_train['CNN'][image_name]).reshape(1, -1).astype('float32')
        index_cnn.add(cnn)

        # ORB
        sift_vector = np.array(caracteristicas_imagenes_train['SIFT'][image_name]).reshape(1, -1).astype('float32')
        index_sift.add(sift_vector)

    except Exception as e:
        print(f"Error añadiendo características de {image_name} a los índices: {e}")

# Confirmar que los índices tienen los vectores correctos
print(f"Total de vectores en índice de color: {index_color.ntotal}")
print(f"Total de vectores en índice de textura: {index_textura.ntotal}")
print(f"Total de vectores en índice de forma: {index_forma.ntotal}")
print(f"Total de vectores en índice de cnn: {index_cnn.ntotal}")
print(f"Total de vectores en índice SIFT: {index_sift.ntotal}")

# Guardar los índices en archivos
faiss.write_index(index_color, os.path.join(DB_PATH, 'color_histogram.index'))
faiss.write_index(index_textura, os.path.join(DB_PATH, 'texture_descriptor.index'))
faiss.write_index(index_forma, os.path.join(DB_PATH, 'shape_descriptor.index'))
faiss.write_index(index_cnn, os.path.join(DB_PATH, 'cnn_descriptor.index'))
faiss.write_index(index_sift, os.path.join(DB_PATH, 'sift_descriptor.index'))